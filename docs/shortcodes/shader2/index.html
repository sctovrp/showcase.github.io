<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Convolución aplicada a shaders # Introducción # Shader # Es un programa informático que realiza cálculos gráficos escrito en un lenguaje de sombreado que se puede compilar independientemente. Es una tecnología que ha experimentado una rápida evolución destinada a proporcionar al programador una interacción con la unidad de procesamiento gráfico (GPU) hasta ahora imposible. Los sombreadores son utilizados para realizar transformaciones de vértices o coloreado de píxeles, entre otras labores, con el propósito de crear efectos especiales, como iluminación, fuego o niebla."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Convolución aplicada a shaders # Introducción # Shader # Es un programa informático que realiza cálculos gráficos escrito en un lenguaje de sombreado que se puede compilar independientemente. Es una tecnología que ha experimentado una rápida evolución destinada a proporcionar al programador una interacción con la unidad de procesamiento gráfico (GPU) hasta ahora imposible. Los sombreadores son utilizados para realizar transformaciones de vértices o coloreado de píxeles, entre otras labores, con el propósito de crear efectos especiales, como iluminación, fuego o niebla."><meta property="og:type" content="article"><meta property="og:url" content="https://sctovrp.github.io/showcase.github.io/docs/shortcodes/shader2/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-26T19:39:57-05:00"><title>Shader2 | Presentación</title><link rel=manifest href=/showcase.github.io/manifest.json><link rel=icon href=/showcase.github.io/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase.github.io/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/showcase.github.io/flexsearch.min.js></script>
<script defer src=/showcase.github.io/en.search.min.147a767592c508ed608e7ee0d58f88f769eeeb9eec7751c5b38c0538713f5cbe.js integrity="sha256-FHp2dZLFCO1gjn7g1Y+I92nu657sd1HFs4wFOHE/XL4=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase.github.io/><span>Presentación</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/showcase.github.io/docs/shortcodes/convolution/>Convolution</a></li><li><a href=/showcase.github.io/docs/shortcodes/convolutionVideo/>Convolution Video</a></li><li><a href=/showcase.github.io/docs/shortcodes/scenegraph/>Scenegraph</a></li><li><a href=/showcase.github.io/docs/shortcodes/shader1/>Shader1</a></li><li><a href=/showcase.github.io/docs/shortcodes/shader2/ class=active>Shader2</a></li><li><a href=/showcase.github.io/docs/shortcodes/softwareRendering/>Software Rendering</a></li></ul></li></ul><ul><li><a href=/showcase.github.io/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase.github.io/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Shader2</strong>
<label for=toc-control><img src=/showcase.github.io/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#convolución-aplicada-a-shaders>Convolución aplicada a shaders</a><ul><li><a href=#introducción>Introducción</a><ul><li><a href=#shader>Shader</a></li><li><a href=#glsl>GLSL</a></li></ul></li><li><a href=#desarrollo>Desarrollo</a><ul><li><a href=#manejo-en-la-instancia-p5>Manejo en la instancia p5</a></li><li><a href=#manejo-en-el-shader>Manejo en el shader</a></li></ul></li><li><a href=#resultados>Resultados</a></li><li><a href=#conclusiones-y-trabajos-futuros>Conclusiones y trabajos futuros</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=convolución-aplicada-a-shaders>Convolución aplicada a shaders
<a class=anchor href=#convoluci%c3%b3n-aplicada-a-shaders>#</a></h1><h2 id=introducción>Introducción
<a class=anchor href=#introducci%c3%b3n>#</a></h2><h3 id=shader>Shader
<a class=anchor href=#shader>#</a></h3><p>Es un programa informático que realiza cálculos gráficos escrito en un lenguaje de sombreado que se puede compilar independientemente. Es una tecnología que ha experimentado una rápida evolución destinada a proporcionar al programador una interacción con la unidad de procesamiento gráfico (GPU) hasta ahora imposible. Los sombreadores son utilizados para realizar transformaciones de vértices o coloreado de píxeles, entre otras labores, con el propósito de crear efectos especiales, como iluminación, fuego o niebla.</p><p>Fuente: <a href=https://es.wikipedia.org/wiki/Sombreador>Sombreador - Wikipedia</a></p><h3 id=glsl>GLSL
<a class=anchor href=#glsl>#</a></h3><p>Son las siglas en ingles para openGL Shading Language, el cual es un lenguaje de alto nivel de sombreado con una sintaxis basada en el lenguaje de programación C y RenderMan. Desarrollado para su uso dentro de OpenGL, se ha enfocado en permitir altos niveles de paralelismo en su ejecución.</p><p>Fuente: <a href=https://thebookofshaders.com/01/>Getting started - What is a fragment shader?</a></p><p>Con el anterior marco teórico presente, el ejercicio presente es aprovechar el uso de shaders para crear programas que hagan calculos en paralelo, haciendo uso del lenguaje GLSL.</p><p>El ejercicio propuesto está en aplicar el filtro gaussiano y el filtro laplaciano a la imagen trabajada en la sección enfocada a convolución.</p><h2 id=desarrollo>Desarrollo
<a class=anchor href=#desarrollo>#</a></h2><h3 id=manejo-en-la-instancia-p5>Manejo en la instancia p5
<a class=anchor href=#manejo-en-la-instancia-p5>#</a></h3><p>Lo primero es definir la instancia p5 y las variables necesarias, así como la función generadora del filtro gaussiano. También se aplicó un filtro Laplaciano simple retomado de esta <a href=http://matematicas.uam.es/~fernando.chamizo/dark/d_simimf.html>pagina web</a>.</p><details><summary>Función del kernel de Gauss</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>p5</span>((<span style=color:#a6e22e>p</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>gaussKernel</span>(<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>sigma</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>kernel</span> <span style=color:#f92672>=</span> [...Array(<span style=color:#a6e22e>size</span>)].<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>e</span> =&gt; Array(<span style=color:#a6e22e>size</span>).<span style=color:#a6e22e>fill</span>(<span style=color:#a6e22e>value</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>sum</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> (<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>-</span> (<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kernel</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>exp</span>(((Math.<span style=color:#a6e22e>pow</span>(<span style=color:#a6e22e>x</span>, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> Math.<span style=color:#a6e22e>pow</span>(<span style=color:#a6e22e>y</span>, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>/</span> ((<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>pow</span>(<span style=color:#a6e22e>sigma</span>, <span style=color:#ae81ff>2</span>)))) <span style=color:#f92672>*</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>kernel</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>kernel</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>] <span style=color:#f92672>/=</span> <span style=color:#a6e22e>sum</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vector</span> <span style=color:#f92672>=</span> [].<span style=color:#a6e22e>concat</span>(...<span style=color:#a6e22e>kernel</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>vector</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div></details><p>Luego en la función <code>preload()</code> de p5 hacemos referencia al archivo donde tenemos el shader y la imagen que deseamos modificar</p><details><summary>Función preload</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>preload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>conShader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>readShader</span>(<span style=color:#e6db74>&#39;./../../../sketches/shaders/mask.frag&#39;</span>, { <span style=color:#a6e22e>varyings</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Tree</span>.<span style=color:#a6e22e>texcoords2</span> });
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>img</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>loadImage</span>(<span style=color:#e6db74>&#34;../../../2.png&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>Ahora bien, tenemos que transmitir mediante variables uniformes datos importantes para poder realizar la convolución en el shader.
Es importante recordar que el shader se aplica a todos los píxeles que se encuentran en la imagen, facilitándonos el proceso de iterar a través de la misma.</p><p>En esta situación, debemos pues es enviar:</p><ul><li>La imagen que deseamos modificar.</li><li>El kernel que contiene los valores correctos para aplicar el filtro.</li><li>El desplazamiento dentro del kernel para aplicar correctamente los valores del kernel en la imagen, es decir su desplazamiento relativo dentro de la imagen.</li></ul><p>Esto podremos apreciarlo en la siguiente función:</p><details><summary>Función fragment</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fragment</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// define shader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>shader</span>(<span style=color:#a6e22e>conShader</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// send img and mask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;texture&#39;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;mask&#39;</span>, <span style=color:#a6e22e>mask</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;maskSharpening&#39;</span>, <span style=color:#a6e22e>maskSharpening</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// define and send texOffset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>texOffset</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>width</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>height</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;texOffset&#39;</span>, <span style=color:#a6e22e>texOffset</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>Ahora bien, dentro de la función <code>setup()</code> definimos el espacio de trabajo y las banderas que vamos a utilizar para saber cuál filtro se va a mandar.</p><details><summary>Función setup</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>setup</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>700</span>, <span style=color:#ae81ff>500</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>WEBGL</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>noStroke</span>();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>textureMode</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>NORMAL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// define and send filter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>filter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>createCheckbox</span>(<span style=color:#e6db74>&#39;gaussian filter&#39;</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>createCheckbox</span>(<span style=color:#e6db74>&#39;sharpening filter&#39;</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter3</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>createCheckbox</span>(<span style=color:#e6db74>&#39;both filters&#39;</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;color&#39;</span>, <span style=color:#e6db74>&#39;white&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>input</span>(() =&gt; <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;filter&#39;</span>, <span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>checked</span>()));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter2</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;color&#39;</span>, <span style=color:#e6db74>&#39;white&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter2</span>.<span style=color:#a6e22e>input</span>(() =&gt; <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;filter&#39;</span>, <span style=color:#a6e22e>filter2</span>.<span style=color:#a6e22e>checked</span>()));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter3</span>.<span style=color:#a6e22e>style</span>(<span style=color:#e6db74>&#39;color&#39;</span>, <span style=color:#e6db74>&#39;white&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>filter3</span>.<span style=color:#a6e22e>input</span>(() =&gt; <span style=color:#a6e22e>conShader</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#39;filter&#39;</span>, <span style=color:#a6e22e>filter3</span>.<span style=color:#a6e22e>checked</span>()));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p>Por último, en la función <code>draw()</code>, actualizaremos el espacio de trabajo y las variables según la elección de filtro que vayamos a utilizar.</p><details><summary>Función draw</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>draw</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fragment</span>(<span style=color:#a6e22e>mask</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>filter</span>.<span style=color:#a6e22e>checked</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create mask
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>mask</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gaussKernel</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>filter2</span>.<span style=color:#a6e22e>checked</span>()) {
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mask</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maskSharpening</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>filter3</span>.<span style=color:#a6e22e>checked</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>mask</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>mask</span> <span style=color:#f92672>=</span> Array(<span style=color:#a6e22e>maskSharpening</span>.<span style=color:#a6e22e>length</span>).<span style=color:#a6e22e>fill</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>newMask</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>mask</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newMask</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>mask</span>[<span style=color:#a6e22e>index</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>maskSharpening</span>[<span style=color:#a6e22e>index</span>])
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mask</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newMask</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h3 id=manejo-en-el-shader>Manejo en el shader
<a class=anchor href=#manejo-en-el-shader>#</a></h3><p>Dentro del archivo <code>.frag</code>, debemos de hacer coincidir el nombre de aquellas variables uniformes que mandamos desde la instancia p5.</p><details><summary>Variables en .frag</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-frag data-lang=frag><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> texture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> texOffset;
</span></span><span style=display:flex><span><span style=color:#75715e>// holds the 3x3 kernel</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> mask[<span style=color:#ae81ff>9</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>bool</span> filter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// we need our interpolated tex coord</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> texcoords2;
</span></span></code></pre></div></div></details><p>En la función <code>main()</code> es obtener los valores respectivos de la imagen en las coordinadas correctas que se reflejan al superponer el kernel. Luego con estos valores, multiplicamos los valores de la imagen con los del kernel.</p><p>Una vez hecho esto, se aplica los valores obtenidos sobre la imagen.</p><details><summary>Función main</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-frag data-lang=frag><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. Use offset to move along texture space.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc0 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>-</span>texOffset.s, <span style=color:#f92672>-</span>texOffset.t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc1 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(         <span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>-</span>texOffset.t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc2 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>+</span>texOffset.s, <span style=color:#f92672>-</span>texOffset.t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc3 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>-</span>texOffset.s,          <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc4 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(         <span style=color:#ae81ff>0.0</span>,          <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc5 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>+</span>texOffset.s,          <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc6 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>-</span>texOffset.s, <span style=color:#f92672>+</span>texOffset.t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc7 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(         <span style=color:#ae81ff>0.0</span>, <span style=color:#f92672>+</span>texOffset.t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> tc8 <span style=color:#f92672>=</span> texcoords2 <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec2</span>(<span style=color:#f92672>+</span>texOffset.s, <span style=color:#f92672>+</span>texOffset.t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Sample texel neighbours within the rgba array</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec4</span> rgba[<span style=color:#ae81ff>9</span>];
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> texture2D(texture, tc0);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> texture2D(texture, tc1);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> texture2D(texture, tc2);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> texture2D(texture, tc3);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> texture2D(texture, tc4);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> texture2D(texture, tc5);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> texture2D(texture, tc6);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> texture2D(texture, tc7);
</span></span><span style=display:flex><span>    rgba[<span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> texture2D(texture, tc8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. Apply convolution kernel</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec4</span> convolution;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>9</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        convolution <span style=color:#f92672>+=</span> rgba[i]<span style=color:#f92672>*</span>mask[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. Set color from convolution or let img without modification</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (filter) {
</span></span><span style=display:flex><span>        gl_FragColor <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec4</span>(convolution.rgb, <span style=color:#ae81ff>1.0</span>); 
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        gl_FragColor <span style=color:#f92672>=</span> rgba[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=resultados>Resultados
<a class=anchor href=#resultados>#</a></h2><p>La implementación anteriormente descrita se encuentra en este lienzo aplicado a una imagen.</p><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/addons/p5.sound.min.js></script>
<script src=../../../sketches/p5.treegl.js></script>
<script src=../../../sketches/shader2img.js></script><div id=shader2img></div><p>En este lienzo se encuentra la implementación se esta aplicando a un video.</p><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/addons/p5.sound.min.js></script>
<script src=../../../sketches/p5.treegl.js></script>
<script src=../../../sketches/shader2.js></script><div id=shader2></div><p>Ahora si se compara con la implementación realizada anteriormente en este blog, claramente se puede ver la diferencia en el framerate, incluso, en el hecho de visualizar ambos lienzos con el efecto activado sin ningún inconveniente o disminución en el framerate.</p><a href=/showcase.github.io/docs/shortcodes/convolutionVideo/ class=book-btn>Convolución aplicada a video</a><h2 id=conclusiones-y-trabajos-futuros>Conclusiones y trabajos futuros
<a class=anchor href=#conclusiones-y-trabajos-futuros>#</a></h2><p>Podemos concluir que el uso de shaders hace más eficiente la implementación de convoluciones en archivos de imágenes o video, cumpliendo así, una meta de estudio propuesta anteriormente para ambos aspectos. Queda pues, la invitación a revisar su uso en otros aspectos, que permitan realizar proyectos de diversa índole temática y técnica.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/ba0fa2ae7d6d238b2e838c852f8bdefdca0970ed title='Last modified by Sebastian Tovar | June 27, 2022' target=_blank rel=noopener><img src=/showcase.github.io/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 27, 2022</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#convolución-aplicada-a-shaders>Convolución aplicada a shaders</a><ul><li><a href=#introducción>Introducción</a><ul><li><a href=#shader>Shader</a></li><li><a href=#glsl>GLSL</a></li></ul></li><li><a href=#desarrollo>Desarrollo</a><ul><li><a href=#manejo-en-la-instancia-p5>Manejo en la instancia p5</a></li><li><a href=#manejo-en-el-shader>Manejo en el shader</a></li></ul></li><li><a href=#resultados>Resultados</a></li><li><a href=#conclusiones-y-trabajos-futuros>Conclusiones y trabajos futuros</a></li></ul></li></ul></nav></div></aside></main></body></html>